import capstone


jump_branch_instructions = ["jmp", "jz", "jnz", "je", "jne", "jl", "jle", "jg", "jge"]


def parse_instructions(line_bytes):
    md = capstone.Cs(capstone.CS_ARCH_X86, capstone.CS_MODE_64)
    return [(insn.mnemonic, insn.op_str) for insn in md.disasm(line_bytes, 0)]


def create_basic_blocks(lines):
    basic_blocks = []
    current_basicblock = []

    for line in lines:
        instructions = parse_instructions(line)
        if instructions and instructions[0][0] in jump_branch_instructions:
            if current_basicblock:
                basic_blocks.append(current_basicblock)
            basic_blocks.append([instructions])
            current_basicblock = []
        else:
            current_basicblock.append(instructions)

    if current_basicblock:
        basic_blocks.append(current_basicblock)

    return basic_blocks


def create_control_flow_graph(basic_blocks):
    graph = {}

    for i, basic_block in enumerate(basic_blocks):
        last_instruction = basic_block[-1][-1]

        if last_instruction[0] in jump_branch_instructions:
            target_addr = int(last_instruction[1], 16)

            for j, basic_block2 in enumerate(basic_blocks):
                if basic_block2[0][0][1] == hex(target_addr):
                    if i not in graph:
                        graph[i] = set()
                    graph[i].add(j)
                    break

    return graph


def get_control_flow_graph(file_bytes):
    basic_blocks = create_basic_blocks(file_bytes)
    control_flow_graph = create_control_flow_graph(basic_blocks)

    return control_flow_graph
